# 进程、线程、调度

http://static.kancloud.cn/zhangyi8928/kernel/531016


**进程**是处于执行期的程序以及相关的资源的总称，是操作系统资源分配的单位。

## 进程描述符
linux 通过 **task_struct** 结构体描述一个进程。

- mm 成员：描述内存资源
- fs 成员：描述文件系统资源
- files成员：进程运行时打开了多少文件，fd的数组
- signal成员：进程接收的信号资源

![process](/assets/img/linux/process.png)


Linux 通过 slab 分配器分配 task_struct 结构，只需要在栈底创建新的结构 struct_thread_info。每个任务的 thread_info 结构在内核栈的尾端分配。

pid的数据是有限的

```
$ cat /proc/sys/kernel/pid_max
32768
```

在 Linux 系统中，进程和线程都是通过 task_struct 结构体来描述，进程之间不共享地址空间，而线程和创建它的进程是共享地址空间的。

线程又分为：**内核线程**、**用户线程**和**协程**。


对于IO密集型，多线程处理未必能提高CPU使用率，反而会增加线程切换的开销。多线程之间存在临界区或者共享数据，那么同步的开销也不低。一个用户线程可以跑多个协程，以此提升单核的利用率。


## 僵尸进程
僵尸是子进程已经死了，资源已经释放。但是父进程还没有wait回收，task_struct还在，父进程可以查询到子进程的死因。

kill -9 僵尸进程  无效， 僵尸进程是一个特别短暂的状态。

## 停止状态与作业控制 cpulimit
Linux 在早期使用 cpulimit 进行 cpu 利用率的控制。
```
# 把进程 12296 的 CPU 使用率控制在 10% 以下
cpulimit -l 10 -p 12296
```

## 进程的睡眠
深度睡眠和浅度睡眠都是自发的，停止态是被动的。

- 深 ：必须等到资源才能 wake_up
- 浅 ：除了被资源 wake_up，还可以被信号唤醒

睡眠是主动的，暂停是人为的控制信号，属于作业控制。深度睡眠，只能在内核中进行。
睡眠态等到资源后，先就绪。


## 内核的调度算法
根据 task_struct 结构体来进行调度的。

